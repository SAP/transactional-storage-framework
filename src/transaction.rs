// SPDX-FileCopyrightText: 2021 Changgyoo Park <wvwwvwwv@me.com>
//
// SPDX-License-Identifier: Apache-2.0

use super::{Error, Log, Sequencer, Storage};
use crossbeam_epoch::{Atomic, Guard, Owned, Shared};
use crossbeam_utils::atomic::AtomicCell;
use std::sync::atomic::Ordering::Relaxed;

/// Transaction is the atomic unit of work for all types of the storage operations.
///
/// A single strand of change records constitues a single transaction.
/// An on-going transaction can be rewound to a certain point of time.
pub struct Transaction<'s, S: Sequencer> {
    /// The transaction refers to a Storage instance to persist pending changes at commit.
    storage: &'s Storage<S>,
    /// The transaction refers to a Sequencer instance in order to assign a clock value for commit.
    sequencer: &'s S,
    /// transaction_cell contains data that can be shared and may outlive the transaction.
    transaction_cell: Atomic<TransactionCell<S>>,
    /// log_records contains a list of log records generated by a transaction.
    log_records: std::sync::Mutex<Vec<Log>>,
}

impl<'s, S: Sequencer> Transaction<'s, S> {
    /// Creates a new Transaction.
    ///
    /// # Examples
    /// ```
    /// use tss::{DefaultSequencer, Storage, Transaction};
    ///
    /// let storage: Storage<DefaultSequencer> = Storage::new(String::from("db"));
    /// let transaction = storage.transaction();
    /// ```
    pub fn new(storage: &'s Storage<S>, sequencer: &'s S) -> Transaction<'s, S> {
        Transaction {
            storage,
            sequencer,
            transaction_cell: Atomic::from(Owned::new(TransactionCell::new(sequencer))),
            log_records: std::sync::Mutex::new(Vec::new()),
        }
    }

    /// Returns a shared pointer to the TransactionCell.
    ///
    /// # Examples
    /// ```
    /// use tss::{DefaultSequencer, Storage, Transaction};
    ///
    /// let storage: Storage<DefaultSequencer> = Storage::new(String::from("db"));
    /// let transaction = storage.transaction();
    /// let guard = crossbeam_epoch::pin();
    /// assert!(!transaction.transaction_cell(&guard).is_null());
    pub fn transaction_cell<'g>(&self, guard: &'g Guard) -> Shared<'g, TransactionCell<S>> {
        self.transaction_cell.load(Relaxed, guard)
    }

    /// Gets the current transaction-local clock value of the Transaction.
    ///
    /// It returns the size of the log record vector.
    ///
    /// # Examples
    /// ```
    /// use tss::{DefaultSequencer, Storage, Transaction};
    ///
    /// let storage: Storage<DefaultSequencer> = Storage::new(String::from("db"));
    /// let transaction = storage.transaction();
    ///assert_eq!(transaction.clock(), 0);
    pub fn clock(&self) -> usize {
        self.log_records.lock().unwrap().len()
    }

    /// Advances the logical clock of the transaction by one by feeding a chunk of log records.
    ///
    /// This operation can be mapped to completion of statement execution in terms of database management software.
    ///
    /// # Examples
    /// ```
    /// use tss::{DefaultSequencer, Log, Storage, Transaction};
    ///
    /// let storage: Storage<DefaultSequencer> = Storage::new(String::from("db"));
    /// let transaction = storage.transaction();
    /// assert_eq!(transaction.advance(Log::new()), 1);
    /// ```
    pub fn advance(&self, log: Log) -> usize {
        let mut log_records = self.log_records.lock().unwrap();
        log_records.push(log);
        log_records.len()
    }

    /// Rewinds the Transaction to the given point of time.
    ///
    /// All the changes made between the latest transaction-local clock and the given one are reverted.
    ///
    /// # Examples
    /// ```
    /// use tss::{DefaultSequencer, Log, Storage, Transaction};
    ///
    /// let storage: Storage<DefaultSequencer> = Storage::new(String::from("db"));
    /// let mut transaction = storage.transaction();
    /// let result = transaction.rewind(1);
    /// assert!(result.is_err());
    ///
    /// transaction.advance(Log::new());
    /// let result = transaction.rewind(0);
    /// assert!(result.is_ok());
    /// ```
    pub fn rewind(&mut self, transaction_local_clock: usize) -> Result<usize, Error> {
        let mut log_records = self.log_records.lock().unwrap();
        if log_records.len() <= transaction_local_clock {
            Err(Error::Fail)
        } else {
            while log_records.len() > transaction_local_clock {
                if let Some(log) = log_records.pop() {
                    log.undo();
                }
            }
            Ok(log_records.len())
        }
    }

    /// Commits the changes made by the Transaction.
    ///
    /// # Examples
    /// ```
    /// use tss::{DefaultSequencer, Storage, Transaction};
    ///
    /// let storage: Storage<DefaultSequencer> = Storage::new(String::from("db"));
    /// let mut transaction = storage.transaction();
    /// transaction.commit();
    /// ```
    pub fn commit(self) -> Result<Rubicon<'s, S>, Error> {
        // Assigns a new logical clock.
        let guard = crossbeam_epoch::pin();
        let transaction_cell_shared = self.transaction_cell(&guard);
        if transaction_cell_shared.is_null() {
            return Err(Error::Fail);
        }
        let transaction_cell_ref = unsafe { transaction_cell_shared.deref() };
        transaction_cell_ref
            .snapshot
            .store(self.sequencer.advance());
        Ok(Rubicon {
            transaction: Some(self),
        })
    }

    /// Rolls back the changes made by the Transaction.
    ///
    /// If there is nothing to rollback, it returns false.
    ///
    /// # Examples
    /// ```
    /// use tss::{DefaultSequencer, Storage, Transaction};
    ///
    /// let storage: Storage<DefaultSequencer> = Storage::new(String::from("db"));
    /// let mut transaction = storage.transaction();
    /// transaction.rollback();
    /// ```
    pub fn rollback(self) {
        // Dropping the instance entails a synchronous transaction rollback.
        drop(self);
    }

    /// Post-processes transaction commit.
    ///
    /// Only a Rubicon instance is allowed to call this function.
    /// Once the Transaction is post-processed, the Transaction cannot be rolled back.
    fn post_process(self) {}
}

impl<'s, S: Sequencer> Drop for Transaction<'s, S> {
    fn drop(&mut self) {
        // Rolls back the Transaction if not committed.
        let guard = crossbeam_epoch::pin();
        let cell_shared = self.transaction_cell.load(Relaxed, &guard);
        if !cell_shared.is_null() {
            // Rewinds the transaction.
            let _result = self.rewind(0);
            // The transaction cell has neither passed to other components nor consumed.
            drop(unsafe { cell_shared.into_owned() });
        }
    }
}

/// Rubicon gives one last chance of rolling back the Transaction.
///
/// The Transaction is bound to be committed if no actions are taken before dropping the Rubicon
/// instance. On the other hands, the transaction stays uncommitted until the Rubicon instance is
/// dropped.
///
/// The fact that the Transaction is stopped just before being fully committed enables developers
/// to implement a distributed transaction commit protocols, such as the two-phase-commit protocol,
/// or X/Open XA. One will be able to regard a state where a piece of code holding a Rubicon
/// instance as being a state where the distributed transaction is prepared.
pub struct Rubicon<'s, S: Sequencer> {
    transaction: Option<Transaction<'s, S>>,
}

impl<'s, S: Sequencer> Rubicon<'s, S> {
    /// Rolls back a committable Transaction.
    ///
    /// If there is nothing to rollback, it returns false.
    ///
    /// # Examples
    /// ```
    /// use tss::{DefaultSequencer, Storage, Transaction};
    ///
    /// let storage: Storage<DefaultSequencer> = Storage::new(String::from("db"));
    /// let mut transaction = storage.transaction();
    /// if let Ok(rubicon) = transaction.commit() {
    ///     rubicon.rollback();
    /// }
    ///
    /// let mut transaction = storage.transaction();
    /// transaction.commit();
    /// ```
    pub fn rollback(mut self) {
        if let Some(transaction) = self.transaction.take() {
            transaction.rollback();
        }
    }
}

impl<'s, S: Sequencer> Drop for Rubicon<'s, S> {
    /// Post-processes the transaction that is not explicitly rolled back.
    fn drop(&mut self) {
        if let Some(transaction) = self.transaction.take() {
            transaction.post_process();
        }
    }
}

/// TransactionCell is a piece of data that represents the future snapshot when the transaction is committed.
///
/// If the Transaction is rolled back, the TransactionCell is dropped without being updated.
pub struct TransactionCell<S: Sequencer> {
    snapshot: AtomicCell<S::Clock>,
}

impl<S: Sequencer> TransactionCell<S> {
    fn new(sequencer: &S) -> TransactionCell<S> {
        TransactionCell {
            snapshot: AtomicCell::new(S::invalid()),
        }
    }

    pub fn snapshot(&self) -> S::Clock {
        self.snapshot.load()
    }
}
